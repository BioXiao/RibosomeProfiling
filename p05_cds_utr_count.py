import glob,os,argparse
from natsort import natsorted
import pandas as pd
from multiprocessing import Pool


parser = argparse.ArgumentParser(description='Get read count at cds, utr5 and utr3 for each protein')
parser.add_argument('-g','--gff_path',action='store',dest='gff_path',help='path to all files generated by p01_prepare_annotation.py')
parser.add_argument('-p','--pos_cov',action='store',dest='pos_cov',help='path that has coverage at each position for each transcript at mapping length with the same offset')
parser.add_argument('-t','--thread',action='store',dest='thread',type=int,help='thread to use',default=1)
parser.add_argument('-e','--end',action='store',dest='end',help='which end of read to use',default=5)
args = parser.parse_args()




db_path = args.gff_path
if db_path.endswith('/'): db_path = db_path[:-1]
tr_cov_path = args.pos_cov
end = args.end
thread = args.thread



def get_cds_utr_count(tr_covFolder,long_utr_fn,outFile,end):
    '''this function gets total count in cds, utr5 and utr3 region of each protein
    and writes the results into a file
    '''
    # prepare {pr:utr5 and utr3}
    utr_df = pd.read_csv(long_utr_fn,sep='\t',header=0)
    utr_df[['utr5_len','utr3_len']] = utr_df[['utr5_len','utr3_len']].astype('int')
    utr5_dic = utr_df.set_index('PrAccess')['utr5_len'].to_dict()
    utr3_dic = utr_df.set_index('PrAccess')['utr3_len'].to_dict()
    # get total coverage at CDS, UTR and intergenic regions
    # dictioanry format is {praccess:{offset:count}}
    cds_cov_dic = {}
    utr5_cov_dic = {}
    utr3_cov_dic = {}
    pos_cov_files = glob.glob(tr_covFolder+'/*.txt')
    for pf in pos_cov_files:
        # get offset length
        offset = int(pf[:-4].split('_')[-1])
        if str(end) == '3':
            offset = - offset
        with open(pf) as f:
            for line in f:
                item = line.strip().split('\t')
                pr = item[1]
                utr5 = utr5_dic[pr]
                utr3 = utr3_dic[pr]
                # cds coverage
                cov = [int(p) for p in item[2:]]
                cds_cov    = cov[50+utr5-offset:len(cov)-50-utr3-offset]
                cds_count  = sum(cds_cov)
                # utr5 coverage
                utr5_cov   = cov[50-offset:50+utr5-offset]
                utr5_count = sum(utr5_cov)
                # utr3 coverage
                utr3_cov   = cov[len(cov)-50-utr3-offset:len(cov)-50-offset]
                utr3_count = sum(utr3_cov)
                if pr in cds_cov_dic:
                    cds_cov_dic[pr][offset]  = cds_count
                    utr5_cov_dic[pr][offset] = utr5_count
                    utr3_cov_dic[pr][offset] = utr3_count
                else:
                    cds_cov_dic[pr]  = {offset:cds_count}
                    utr5_cov_dic[pr] = {offset:utr5_count}
                    utr3_cov_dic[pr] = {offset:utr3_count}            
    with open(outFile,'w') as f:
        f.write('\t'.join(['PrAccess','cds_count','utr5_count','utr3_count'])+'\n')
        for pr in natsorted(cds_cov_dic.keys()):
            cds_t  = str(sum(cds_cov_dic[pr].values()))
            utr5_t = str(sum(utr5_cov_dic[pr].values()))
            utr3_t = str(sum(utr3_cov_dic[pr].values()))
            f.write('\t'.join([pr,cds_t,utr5_t,utr3_t])+'\n')


import time
start = time.time()

cds_utr5_utr3_count_path = os.path.dirname(tr_cov_path) + '/05_cds_utr_count'
if not os.path.exists(cds_utr5_utr3_count_path): os.mkdir(cds_utr5_utr3_count_path)
long_utr_fn = db_path + '/04_long_utr_len.txt'
tr_covFolders = natsorted([f for f in glob.glob(tr_cov_path+'/*') if os.path.isdir(f)])


p = Pool(processes=thread)
for tr_covFolder in tr_covFolders:
    cds_utr_count_fn = cds_utr5_utr3_count_path + '/' + os.path.basename(tr_covFolder) + '.txt'
    p.apply_async(get_cds_utr_count,args=(tr_covFolder,long_utr_fn,cds_utr_count_fn,end,))
p.close()
p.join()
# get_cds_utr_count(tr_covFolder,long_utr_fn,cds_utr_count_fn)

print('get count for transcript CDS, UTR5/3 finished')
print('total run time is: '+str((time.time()-start)/60) +' minutes')